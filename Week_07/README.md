# 学习笔记

算法题的作业每道题为一个md文件，每道题包含一种或多种解法，每种解法都包含解题思路、代码实现和复杂度分析。

## 第13课  字典树和并查集

### 一、字典树的基本实现和特性

字典树，即Trie树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。

它的优点是：最大限度地减少无谓地字符串比较，查询效率比哈希表高。

字典树的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

字典树具有如下性质。

1. 节点本身不存完整单词。
2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点路径代表的字符都不相同。

### 二、并查集的基本实现和特性

并查集常用于组团和配对问题。

并查集包含三个主要函数：建立包含单元素集合的新并查集、把两个元素所在的集合合并、找到某个元素所在的集合的代表（也可用于判断两个元素是否位于同一个集合）。

并查集有标准的实现模板，也可以在实现中进行优化。

### 三、作业：分析单词搜索 II 用字典树方式实现的时间复杂度

时间复杂度：O(4·3^(k-1)·mn)，其中k是单词的最大长度，m和n分别是二维网格的行数和列数。

需要遍历二维网格中的所有元素，最多有4个方向，每次除了到来的单元格以外还有3个相邻的单元格。

## 第14课  高级搜索

### 一、剪枝的实现和特性

剪枝适用于对状态树进行搜索的场景。

如果发现一个分支已经处理过，则可以把处理结果存在缓存中，整个分支就能剪掉。

如果发现一个分支不是最优的，则在求最优解问题的场景下，可以把这样的分支剪掉。

剪枝的目的是减小搜索空间，降低时间复杂度。

### 二、双向BFS的实现和特性

从开始和结束两个位置同时进行BFS，第一次相遇的位置为中间位置，计算两边的层数之和即为开始和结束位置之间的总层数。

### 三、启发式搜索的实现和特性

启发式搜索常用优先队列，优先队列的优先级需要通过启发式函数/估价函数决定。

启发式函数用来评价哪些节点最有可能是要找的节点，函数返回一个非负实数，也可以认为是从当前节点到目标节点路径的估计成本。

启发式函数是一种告知搜索方向的方法，它提供了一种明智的方法来猜测哪个邻居节点会导向一个目标。

### 四、作业：总结双向BFS代码模板

此处的代码模板使用Java。

```
class BidirectionalBFS {
    public int bidirectionalBFS(Map<Integer, List<Integer>> graph, int start, int end) {
        Set<Integer> visited = new HashSet<Integer>();
        Set<Integer> startVisited = new HashSet<Integer>();
        startVisited.add(start);
        Set<Integer> endVisited = new HashSet<Integer>();
        endVisited.add(end);
        int step = 0;
        while (!startVisited.isEmpty() && !endVisited.isEmpty()) {
            if (startVisited.size() > endVisited.size()) {
                Set<Integer> temp = startVisited;
                startVisited = endVisited;
                endVisited = temp;
            }
            step++;
            Set<Integer> nextLevelVisited = new HashSet<Integer>();
            for (int node : startVisited) {
                process(node, nextLevelVisited);
                for (int nextNode : nextLevelVisited) {
                    if (endVisited.contains(nextNode)) {
                        return step;
                    }
                }
            }
            startVisited = nextLevelVisited;
        }
        return 0;
    }
}
```

## 第15课  AVL树和红黑树

二叉搜索树如果在维护过程中不进行特殊处理，则可能出现不平衡，极端情况下退化成链表。

为了保证二叉搜索树的性能，需要保证其二维维度，即左右子树的节点平衡。

### 一、AVL树

AVL树是平衡二叉搜索树。

定义平衡因子是左子树的高度减去右子树的高度（有时相反）。AVL树的平衡因子的绝对值不超过1。

通过旋转操作来进行平衡，共有四种旋转操作：左旋、右旋、左右旋、右左旋。

AVL树的不足：节点需要存储额外信息，且调整次数频繁。

### 二、红黑树

红黑树是近似平衡二叉搜索树，确保任何一个节点的左右子树的高度差小于两倍。红黑树是满足如下条件的二叉搜索树：

- 每个节点是红色或黑色；

- 根节点是黑色；

- 每个叶节点（NIL节点，空节点）是黑色；

- 不能有相邻的两个红色节点；

- 从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点。

红黑树的关键性质：从根节点到叶节点的最长的可能路径不多于最短的可能路径的两倍长。

### 三、AVL树和红黑树的对比

- 查询方面，AVL树比红黑树快，因为AVL树是更严格的平衡二叉搜索树。

- 插入和删除操作方面，红黑树比AVL树快，因为红黑树对平衡性的要求较低，需要的旋转操作更少。

- AVL树需要在每个节点存储平衡因子或者高度，因此需要更多空间，红黑树只需要一个比特记录节点颜色。

- 红黑树在大多数高级语言的库中使用，AVL树常用于数据库中，数据库中需要快速查询。
